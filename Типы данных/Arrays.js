// ПРОЧИТАТЬ: https://learn.javascript.ru/array

// создание пустого массива
let arr = new Array();
let arr1 = [];

// Массив с начальными значениями
let fruits = ["Яблоко", "Апельсин", "Слива"];

fruits[2] = 'Груша';    // Мы можем заменить элемент

console.log (
    fruits[0],      // "Яблоко"
    fruits[1],      // "Апельсин"
    fruits[2],      // "Груша"
    fruits.length,  // 3. Общее число элементов массива
    fruits,         // ['Яблоко', 'Апельсин', 'Груша']. Вывести массив целиком
    fruits.at(0),   // "Яблоко".
    fruits.at(-1),  // "Груша". Последний элемент массива
);

// В массиве могут храниться элементы любого типа
arr = [ 'Яблоко',
        { name: 'Джон' },
        true,
        function() { return 'привет'; }
    ];

console.log(
    arr[0],         // "Яблоко"
    arr[1],         // { name: 'Джон' }
    arr[1].name,    // "Джон"
    arr[2],         // true
    arr[3],         // ƒ () { return 'привет'; }
    arr[3](),       // "привет"
);

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
fruits = ["Яблоко", "Апельсин", "Слива", "Груша"];
console.log (fruits.pop(), fruits.shift()); // Груша Яблоко

fruits = ["Яблоко", "Апельсин", "Слива", "Груша"];

fruits.pop();           // удаляет последний элемент
console.log( fruits );  // ['Яблоко', 'Апельсин', 'Слива']

fruits.push("Груша");   // добавляет элемент в конец
console.log( fruits );  // ['Яблоко', 'Апельсин', 'Слива', 'Груша']

fruits.shift();         // удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым
console.log( fruits );  // ['Апельсин', 'Слива', 'Груша']

fruits.unshift("Яблоко");   // добавляет элемент в начало
console.log( fruits );      // ['Яблоко', 'Апельсин', 'Слива', 'Груша']
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// проходит по значениям

fruits = [ 'Яблоко',
        { name: 'Джон' },
        true,
        function() { return 'привет'; }
    ];

// Цикл for..in оптимизирован под произвольные объекты, не массивы, и поэтому в 10-100 раз медленнее
for (let fruit in fruits) { };

// Цикл for..of лучше подходит для массивов
for (let fruit of fruits) {
    console.log( fruit );
};
console.log("\n");
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
arr = [1, 2, 3, 4, 5];
console.log( arr ); // [1, 2, 3, 4, 5]

arr.length = 2;     // укорачиваем до двух элементов
console.log( arr ); // [1, 2]
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Двумерный массив
let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
  ];

console.log(matrix[0][1]);      // 2
console.log(matrix);            // [Array(3), Array(3), Array(3)]
console.log(matrix[0]);         // [1, 2, 3]
console.log(matrix.toString()); // "1,2,3,4,5,6,7,8,9"
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Методы массивов
// ПРОЧИТАТЬ: https://learn.javascript.ru/array-methods

// .splice()
fruits = ["Яблоко", "Апельсин", "Слива", "Груша"];
fruits.splice(1, 2);    // начиная с позиции 1, удалить 2 элемента
console.log( fruits );  // ['Яблоко', 'Груша']

fruits = ["Яблоко", "Апельсин", "Слива", "Груша"];
fruits.splice(1, 2, "AAA", "BBB");  // начиная с позиции 1, удалить 2 элемента, заменяя их на "AAA" и "BBB"
console.log( fruits );              // ['Яблоко', 'AAA', 'BBB', 'Груша']

fruits = ["Яблоко", "Апельсин", "Слива", "Груша"];
arr = ["AAA", "BBB", "CCC"];
fruits.splice(1, 2, ...arr);  // начиная с позиции 1, удалить 2 элемента, заменяя их элементами массива arr
console.log( fruits );        // ['Яблоко', 'AAA', 'BBB', 'CCC', 'Груша']
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// .slice()
fruits = ["Яблоко", "Апельсин", "Слива", "Груша"];

// возвращает новый массив, в который копирует элементы, начиная с индекса start и до end (не включая end)
fruits = fruits.slice(0, 2);
console.log( fruits );          // ['Яблоко', 'Апельсин']

// Можно вызвать slice и вообще без аргументов:
//      arr.slice() создаёт копию массива arr. Это часто используют, чтобы создать копию массива для
//      дальнейших преобразований, которые не должны менять исходный массив.
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// .concat()
// Метод arr.concat создаёт новый массив, в который копирует данные из других
//  массивов и дополнительные значения.

fruits = ["Яблоко", "Апельсин", "Слива", "Груша"];
console.log( fruits.concat("A", "B"));              // ['Яблоко', 'Апельсин', 'Слива', 'Груша', 'A', 'B']

fruits = ["Яблоко", "Апельсин", "Слива", "Груша"];
arr = [1, 2];
console.log( fruits.concat(arr), "\n");             // ['Яблоко', 'Апельсин', 'Слива', 'Груша', 1, 2]
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// arr.forEach() позволяет запускать функцию для каждого элемента массива

fruits = ["Яблоко", "Апельсин", "Слива", "Груша"];

fruits.forEach( elem => {
    console.log( elem );    // "Яблоко", "Апельсин", "Слива", "Груша"
});

fruits.forEach( function(value, index, array) {
    console.log(
        `У элемента '${value}'\tиндекс = ${index}\tв массиве: [${array}]`,
    );
});
console.log("\n");
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/**
 * Поиск в массиве
 * 
 * - arr.indexOf(item, from) ищет item, начиная с индекса from, и возвращает индекс, на котором
 *      был найден искомый элемент, в противном случае -1.
 * - arr.lastIndexOf(item, from) – то же самое, но ищет справа налево.
 * - arr.includes(item, from) – ищет item, начиная с индекса from, и возвращает true, если поиск успешен.
 */

 fruits = ["Яблоко", "Апельсин", "Слива", "Груша"];

 console.log( fruits.includes("Яблоко"), fruits.includes("Я") );        // true false
 console.log( fruits.indexOf("Яблоко"),  fruits.indexOf("Я"));          // 0 -1
 console.log( fruits.lastIndexOf("Яблоко"), fruits.lastIndexOf("Я") );  // 0 -1
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 let users = [
    {id: 1, name: "Вася"},
    {id: 2, name: "Петя"},
    {id: 3, name: "Маша"}
  ];
  
let user = users.find( function(item) {     // найти объект с определённым условием
    return item.name == "Маша";
});
console.log(user);                          // {id: 3, name: 'Маша'}

let userIndex = users.findIndex( function(item) {   // найти индекс объекта с определённым условием
    return item.name == "Маша";
});
console.log(userIndex);                             // 2

// Создать новый массив из элементов, удовлетворяющих условию
let newObj = users.filter( elem => elem.id < 3 );
for (let el of newObj) {
    console.log(el);        // {id: 1, name: 'Вася'} {id: 2, name: 'Петя'}
};
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Преобразование массива
users = [ "3", "1", "2" ];

// Метод arr.map
// Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.
users = users.map ( (elem) => elem = "Bob" );
console.log(users);    // ['Bob', 'Bob', 'Bob']

users = [ 3, 1, 2, 15 ];

// sort()
// сортирует массив на месте, меняя в нём порядок элементов
function compareNumeric(a, b) {
    if (a > b) return 1;
    if (a == b) return 0;
    if (a < b) return -1;
};

users.sort();
console.log(users);         // [1, 15, 2, 3]. Неправильно для чисел

users.sort(compareNumeric); // Специальная функция compareNumeric()
console.log(users);         // [1, 2, 3, 15]. Теперь правильно

users.reverse();            // меняет порядок элементов в массиве на обратный
console.log(users);
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
let str = "a, b, c, d, e";
arr = str.split(', ');      // .split() разбивает строку на массив по заданному разделителю (', ')
console.log(arr);           // ['a', 'b', 'c', 'd', 'e']

arr = str.split(', ', 3);   // второй числовой аргумент – ограничение на количество элементов в массиве
console.log(arr);           // ['a', 'b', 'c']

str = "abcdefgh";
arr = str.split('');        // Разбивка строки по буквам
console.log(arr);           // ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']

let str1 = arr.join('');    // .join() создаёт строку из элементов массива, вставляя символ между ними.
console.log(str1);          // "abcdefgh"
str1 = arr.join(', ');
console.log(str1);          // "a, b, c, d, e, f, g, h"
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
fruits = ["Яблоко", "Апельсин", "Слива", "Груша"];

// Методы arr.reduce и arr.reduceRight используются для вычисления какого-нибудь
//  единого значения на основе всего массива.

let res = fruits.reduce( (sum, current) => sum += " " + current );  // Слева направо
console.log(res);   // "Яблоко Апельсин Слива Груша"

res = fruits.reduceRight( (sum, current) => sum += " " + current ); // Справа налево
console.log(res);   // "Груша Слива Апельсин Яблоко"
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
arr = [1, 2, 3];                // Массив
arr1 = {1:"1", 2:"2", 3:"3"};   // Объект

console.log( typeof arr, typeof arr1);  // object object. Так как массив - объект

// Метод Array.isArray(value) возвращает true, если value массив, и false, если нет.
console.log( Array.isArray( arr ) );   // true. Это массив
console.log( Array.isArray( arr1 ) );  // false. Это не массив
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
arr = [1, 2, 3, 4, 5, 6];
arr = arr.fill("A", 0, 3);  // заполняет массив повторяющимися "A", начиная с индекса 0 до 3.
console.log(arr);           // ['A', 'A', 'A', 4, 5, 6]